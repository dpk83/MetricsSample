// © Microsoft Corporation. All rights reserved.

using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Microsoft.R9.Generators.Metric
{
    internal class Emitter
    {
        private static readonly Regex _regex = new Regex("[:.-]+", RegexOptions.Compiled);

        private readonly string _generatedCodeAttribute =
            $"global::System.CodeDom.Compiler.GeneratedCodeAttribute(" +
            $"\"{typeof(Emitter).Assembly.GetName().Name}\"," +
            $"\"{typeof(Emitter).Assembly.GetName().Version}\")";
        private readonly Stack<StringBuilder> _builders = new();

        public string EmitGenevaMeter(IReadOnlyList<MetricInstrumentClass> metricInstrumentClasses, CancellationToken cancellationToken)
        {
            Dictionary<string, List<MetricInstrumentClass>> metricInstrumentClassesDict = new();
            foreach (var cl in metricInstrumentClasses)
            {
                if (!metricInstrumentClassesDict.ContainsKey(cl.Namespace))
                {
                    metricInstrumentClassesDict.Add(cl.Namespace, new List<MetricInstrumentClass>());
                }

                metricInstrumentClassesDict[cl.Namespace].Add(cl);
            }

            var sb = GetStringBuilder();
            try
            {
                _ = sb.Append("// <auto-generated/>\n");
                _ = sb.Append("#nullable enable\n");

                foreach (var entry in metricInstrumentClassesDict)
                {
                    _ = sb.Append(GenMetricInstrumentFactoryByNamespace(entry.Key, entry.Value, cancellationToken));
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        public string EmitMetricInstruments(IReadOnlyList<MetricInstrumentClass> metricInstrumentClasses, CancellationToken cancellationToken)
        {
            Dictionary<string, List<MetricInstrumentClass>> metricInstrumentClassesDict = new();
            foreach (var cl in metricInstrumentClasses)
            {
                if (!metricInstrumentClassesDict.ContainsKey(cl.Namespace))
                {
                    metricInstrumentClassesDict.Add(cl.Namespace, new List<MetricInstrumentClass>());
                }

                metricInstrumentClassesDict[cl.Namespace].Add(cl);
            }

            var sb = GetStringBuilder();
            try
            {
                _ = sb.Append("// <auto-generated/>\n");
                _ = sb.Append("#nullable enable\n");

                foreach (var entry in metricInstrumentClassesDict)
                {
                    _ = sb.Append(GenTypeByNamespace(entry.Key, entry.Value, cancellationToken));
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private static string GetSanitizedParamName(string paramName)
        {
            return _regex.Replace(paramName, "_");
        }

        private string GenTypeByNamespace(string nspace, IReadOnlyList<MetricInstrumentClass> metricInstrumentClasses, CancellationToken cancellationToken)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var metricInstrumentClass in metricInstrumentClasses)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    _ = sb.Append(GenType(metricInstrumentClass));
                }

                if (string.IsNullOrWhiteSpace(nspace))
                {
                    return $@"
{sb}
";
                }

                return $@"
namespace {nspace}
{{
    {sb}
}}
";
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenMetricInstrumentFactoryByNamespace(string nspace, IReadOnlyList<MetricInstrumentClass> metricInstrumentClasses, CancellationToken cancellationToken)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var metricInstrumentClass in metricInstrumentClasses)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    _ = sb.Append(GenMetricInstrumentFactory(metricInstrumentClass));
                }

                string str = $@"
    public static partial class Metric
    {{
        private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<string, global::Microsoft.R9.Extensions.Meter.ICounterD> _longCounterMetrics = new ();
        {sb}
    }}
";
                if (string.IsNullOrWhiteSpace(nspace))
                {
                    return str;
                }

                return $@"
namespace {nspace}
{{
    {str}
}}
";
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenType(MetricInstrumentClass metricInstrumentClass)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var metricInstrumentMethod in metricInstrumentClass.Methods)
                {
                    _ = sb.Append(GenCounterClass(metricInstrumentMethod));
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenMetricInstrumentFactory(MetricInstrumentClass metricInstrumentClass)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var metricInstrumentMethod in metricInstrumentClass.Methods)
                {
                    _ = sb.Append(GenMetricInstrumentFactoryMethods(metricInstrumentMethod));
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenMetricInstrumentFactoryMethods(MetricInstrumentMethod metricInstrumentMethod)
        {
            var meterParam = metricInstrumentMethod.AllParameters[0];

            return $@"
        [{_generatedCodeAttribute}]
        public static partial {metricInstrumentMethod.MetricName} Create{metricInstrumentMethod.MetricName}(global::{meterParam.Type} {meterParam.Name})
        {{
            string metricName = ""{metricInstrumentMethod.MetricName}"";
            if (_longCounterMetrics.TryGetValue(metricName, out var counterMetric))
            {{
                return (counterMetric as {metricInstrumentMethod.MetricName})!;
            }}

            var metric = _longCounterMetrics.GetOrAdd(metricName, (key) => 
                {{
                    var counter = meter.CreateCounter(metricName{GenDimensionKeys(metricInstrumentMethod)});
                    return new {metricInstrumentMethod.MetricName}(counter as Microsoft.R9.Extensions.Meter.ICounter{metricInstrumentMethod.Dimensions.Count}D);
                }});

            return metric as {metricInstrumentMethod.MetricName};
        }}
";
        }

        private string GenCounterClass(MetricInstrumentMethod metricInstrumentMethod)
        {
            string counterInterfaceName = $"Microsoft.R9.Extensions.Meter.ICounter{metricInstrumentMethod.Dimensions.Count}D";
            return $@"
    [{_generatedCodeAttribute}]
    public class {metricInstrumentMethod.MetricName} : Microsoft.R9.Extensions.Meter.ICounterD
    {{
        {counterInterfaceName} _counter;
        public {metricInstrumentMethod.MetricName}({counterInterfaceName} counter)
        {{
            _counter = counter;
        }}
        {GenClassMethods(metricInstrumentMethod)}
    }}
    ";
        }

        private string GenDimensionKeys(MetricInstrumentMethod metricInstrumentMethod)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var param in metricInstrumentMethod.Dimensions)
                {
                    _ = sb.Append(@$", ""{param}""");
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenDynamicParameters(MetricInstrumentMethod metricInstrumentMethod, bool includeType = true)
        {
            var sb = GetStringBuilder();
            try
            {
                foreach (var dimension in metricInstrumentMethod.Dimensions)
                {
                    if (includeType)
                    {
                        _ = sb.Append($", string {GetSanitizedParamName(dimension)}");
                    }
                    else
                    {
                        _ = sb.Append($", {GetSanitizedParamName(dimension)}");
                    }
                }

                return sb.ToString();
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private string GenClassMethods(MetricInstrumentMethod metricInstrumentMethod)
        {
            var sb = GetStringBuilder();
            try
            {
                int i = 0;
                foreach (var dimension in metricInstrumentMethod.Dimensions)
                {
                    if (i > 0)
                    {
                        _ = sb.Append(", ");
                    }

                    _ = sb.Append(GetSanitizedParamName(dimension));
                    i++;
                }

                string methodName = metricInstrumentMethod.InstrumentType == InstrumentType.Counter ? "Add" : "Record";

                return $@"
        public void {methodName}(long value{GenDynamicParameters(metricInstrumentMethod)})
        {{
            _counter.{methodName}(value{GenDynamicParameters(metricInstrumentMethod, false)});
        }}";
            }
            finally
            {
                ReturnStringBuilder(sb);
            }
        }

        private StringBuilder GetStringBuilder()
        {
            const int DefaultStringBuilderCapacity = 1024;

            if (_builders.Count == 0)
            {
                return new StringBuilder(DefaultStringBuilderCapacity);
            }

            var sb = _builders.Pop();
            _ = sb.Clear();
            return sb;
        }

        private void ReturnStringBuilder(StringBuilder sb)
        {
            _builders.Push(sb);
        }
    }
}
